Http 2 supports 'pushing' of content from servers to clients between supporting clients and servers, without any initiating request from the client.

This is useful when a request for a given resource consistently triggers a request for other resources.  The canonical example is webpage content: when a client requests `index.html` for some domain, the server can be told in advance that the instruction set contained in `index.html` includes instructions to request other resources, and proactively being sending those resources (CSS, JS, etc.) on the same connection, *before* the client has parsed the HTML and sent any subsequent requests.

This is possible because of the frame-based communication [[Http multiplexing]] is based on.  When the server wants to push extra resources to the client, it includes a `PUSH_PROMISE` frame along with the response data to the original request.  The data for this frame type includes *request* headers (rather than the usual response headers) that describe the request for which the data about to be pushed would constitute an appropriate response.  The browser then segregates all data associated with the `PUSH_PROMISE` in a special 'holding zone'.  Outgoing requests are subsequently compared with the data in the holding zone, and if the requests are similar enough, the already-stored data will be used instead of initiating a new request.

In practice server push is [almost never used](https://groups.google.com/a/chromium.org/g/blink-dev/c/K3rYLvmQUBY/m/vOWBKZGoAQAJ?pli=1), and many clients may remove support.  Using `<link rel="preload">` offers nearly the same performance with less complexity in the browser, and can benefit from browser or intermediate caches, whereas a pushing server obviously cannot know the state of any caches between itself and the client.