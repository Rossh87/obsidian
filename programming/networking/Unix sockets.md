In Unix-based OS (MacOS, Linux), Unix sockets or Unix domain sockets are the primary method of inter-process communication (IPC) on a single host. While networking sockets use IP addresses and ports to identify the message recipient, this is not necessary for Unix sockets.

Steps:
1. A process makes a `syscall` to `socket()`, which creates a special file in filesystem's namespace that represents the socket.
2. A process that will be acting as a server makes `syscall` `bind()` to bind the socket to a unique filesystem path, specified by the serving process in the call to `bind()`. That path becomes the unique identifier for the socket and, by extension, the serving process. Other processes can communicate with the serving process by using the unique filepath. In this way, the filepath is analogous to IP:PORT combo for networking sockets. Some care must be taken when binding a filepath to choose a location the process has permission to access, and to match the conventional location for socket file descriptors. On Linux, Unix sockets are conventionally bound to `/tmp` or its subdirectories. However, this is a public directory, so specific sockets or subdirectories should create permissions to meet security needs.
3. After binding, the serving process puts the bound socket in a 'listening' state via `syscall` `listen()`.
4. Clients that wish to connect must also create a socket and `syscall` `connect()` using the filepath of the listening socket. After connection, client and server can exchange data with standard IO operations. Clients can identify listening sockets in various ways. The simplest is through pre-configuration: the client knows the exact filepath the process it wants to communicate with will bind to. It is also possible for serving processes to broadcast listening sockets via multicast systems. In general, clients cannot enumerate all listening sockets b/c of permission restrictions. For this reason, tools like `netstat` should usually be run with `root` privileges.
5. Either party can close their socket. After closing, the socket cannot send further information. It is important that processes cleanup Unix sockets by unbinding and releasing/deleting any other resources that are open.

NB: These steps describe a Unix domain *stream* socket, analogous to a [[TCP]] networking socket. Unix domain *datagram* sockets are also available, and are closer to a [[UDP]] networking socket: there is no `listen` step, and there is less overhead in general. Because Unix socket communication is intra-host, issues with ordering and data loss are less likely to arise for datagram sockets than for networking udp sockets.

Unix sockets are faster and more secure than network sockets because the bypass the networking stack entirely.