1. Single responsibility principle: a class (or code unit, in general, anything that presents an interface to the code around it), should have only one reason to change. Useful [wiki example](https://en.wikipedia.org/wiki/Single_responsibility_principle): Imagine a module that compiles a report, then publishes it in a particular format. This module has 2 reasons to change: The content of the report may change (e.g. may need to come from a different source), or its format may change. B/c of this, the 'formatter' and 'aggregator' portions of the task should be distinct, so that the code responsible for one can be untouched if the other needs to change.
2. Open-close principle: open for extension, closed for modification.  Things like inheritance (blech) or generic interfaces make this easier.  General idea is we don't want to be changing existing code when we add behaviors. This so-called principle is pretty ill-defined; people usually seem to mean something like using interchangeable interfaces for information hiding.
3. Liskov substitution principle: derived classes should be substitutable for parent class.  Illustrative failure case: class `Square` should not inherit from `Rectangle`, because there is a good chance the implementations are not interchangeable.  `Square` should set `width`  AND `height` whenever `setWidth` *or* `setHeight` is called, but `Rectangle` needs them called independently.  Consumers of the interface are likely to call it incorrectly in certain cases. Simply stated: Objects of type _S_ can replace objects of type _T_ anywhere in a program provided _S_ is a subtype of _T_.
4. Interface segregation principle: have lots of smaller interface, not fewer big ones.  Classes can implement multiple smaller interfaces as needed.
5. Dependency inversion principle: depend on abstractions, not concretions.  Abstractions determine implementation, not the other way around. 

Limitations:  It's more code.  Can lead toward premature abstraction.  Can conflict with YAGNI. Slower.