1. https://github.com/conda/conda-lock

Generally we want to use the same direct and transitive dependencies across all environments. `conda export` produces lockfiles with good reproducibility, but are difficult to maintain. `conda-lock` lets us declare and manage dependencies in a regular `environment` file, and create environments from files generated by `conda-lock`. When dependencies change, lock files are regenerated based on the updated `environment.yaml`. 

`conda-lock` generates two types of lock files. `yaml` files must be consumed by `conda-lock`, but are cross-platform compatible. To create an environment from a `yaml`, run
```bash
conda-lock install -n <environment name>	
```

`conda-lock` can also create `.lock` files, which are platform-specific, but can be consumed by `conda` directly. This prevents production images from depending on `conda-lock`.  Get these using `conda-lock render -p <platform>`. Note that if there are `pip` dependencies in `environment.yaml`, `conda` will silently ignore them(!) To install `pip` dependencies from a `.lock` file, you must use `conda-lock install` on a `.lock` file generated by `conda-lock`.

It can be convenient to configure target platforms using non-standard `platform` field in `environment.yaml`.

The way `conda-lock` works is fairly simple. It uses `conda` to solve the environment for the desired platforms and stores the solution in a custom metadata format (`conda-lock.yaml`). Then, either at lock-time or at install-time, it uses that metadata to create a `.lock` file that `conda` knows how to consume. In addition, it writes any `pip` dependencies, including version information to the `.lock` file as comments. On `conda-lock install`, the `.lock` is installed with `conda/mamba`, then any commented `pip` lines are parsed out and written to a temporary `requirements.txt` and installed via `pip install -r`.